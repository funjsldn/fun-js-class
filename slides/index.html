<!DOCTYPE html>
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Functional Programming In Javascript</title>
  
  <link rel="stylesheet" href="reveal/css/reveal.min.css">
  <link rel="stylesheet" href="reveal/lib/css/github.css">

  <link rel="stylesheet" href="slides-theme/style.css">
  <link rel="stylesheet" href="style.css">
</head>

<body>

  <div class="reveal">
    <div class="slides">

      <section data-markdown class=front><script type="text/template">
          # Functional Programming

          Grab code: <br> [github.com/funjsldn/fun-js-class](https://github.com/funjsldn/fun-js-class)

          <div class=spaced>

            [@timruffles](http://twitter.com/timruffles)
            [@mattfieldy](http://twitter.com/mattfieldy)

      </script></section>

      <section data-markdown ><script type="text/template">
          # Hello

          - [github.com/funjsldn/fun-js-class](https://github.com/funjsldn/fun-js-class)
          - Code + slides up above - clone if you've got `git`, or grab the `.zip`.
          - `slides`
          - `exercises`

      </script></section>

      <section data-markdown ><script type="text/template">
          # Higher-Order Functions

          * What are they?
          * How do they work?
          * Why would we use them?
          * Exercises
          
      </script></section>

      <section data-markdown ><script type="text/template">
          # What are HOFs?

          * Functions that do at least one of the following:
          
            1. Take one or more functions as input
            1. Return a function as their result
          
      </script></section>

      <section>

        <pre><code class="javascript">
        function forEach(xs, fn) {
          for (var i = 0; i < xs.length; i++) {
            return fn(xs[i]);
          }
        }
        </code></pre>
        
        <pre><code class="javascript">
        function greaterThan(n) {
          return function(m) {
            return m > n;
          }
        }

        var greaterThan10 = greaterThan(10);
              
        greaterThan10(11);
        //=> true
        </code></pre>
        
      </section>

      <section data-markdown ><script type="text/template">
          ### JavaScript has first-class functions

          <pre><code class="javascript">
              function hello(){
                return "Hello, world!";
              }

              hello();
              //=> "Hello, world!"

              hello;
              //=> "function hello()"

              var ohai = hello;

              ohai();
              //=> "Hello, world!"

              function callThis(f){
                return f();
              }

              callThis(hello);
              //=> "Hello, world!"
              
          </code></pre>
      </script></section>

      <section data-markdown ><script type="text/template">
          # Why would you use them?

          > There are two ways of constructing a software design:
          > One way is to make it so simple that there are obviously no
          > deficiencies and the other way is to make it so complicated
          > that there are no obvious deficiencies
          >
          > -- C.A.R Hoare, 1980 ACM Turing Award Lecture
      </script></section>

      <section data-markdown ><script type="text/template">
          * Which is more likely to contain a bug?
          
          <pre><code class="javascript">
              // Self-contained, six-lines long
              var total = 0, count = 1;
              while (count <= 10) {
                total += count;
                count += 1;
              }
              console.log(total);                
          </code></pre>
          <pre><code class="javascript">
              // Relies on two external functions, one line long
              console.log(sum(range(1, 10)));
              
          </code></pre>

          * Program need to write the second longer than the first, but more likely to be correct
          * By building a language in which to express problem, then solving in terms of the problem's domain, solution gains clarity
            * i.e. summing a range of numbers isn't about loops and counters, but ranges and sums
      </script></section>

      <section>
        <ul>
          <li>Powerful level of abstraction</li>
          <ul>
            <li>Specifically, abstraction over <em>actions</em> not just values</li>
          </ul>
        </ul>

        <pre><code class="javascript">
          function unless(test, then){
            if (!test) then();
          }

          function repeat(times, body){
            for (var i = 0; i < times; i++) body(i);
          }

          repeat(3, function(n){
            unless(n % 2, function(){
              console.log(n, "is even");
            });
          });
        </code></pre>
      </section>

      <section data-markdown ><script type="text/template">
          # Familiar Examples

          Canonical examples:
          
          * map
          * filter
          * reduce
      </script></section>
      
      <section data-markdown><script type="text/template">
          # map

          Takes an array of items and applies a function to each item in that array, then returns a *new* array whose items are the result.

              function map(xs, fn){
                var arr = [];
                for (var i = 0; i < xs.length; i++) {
                  arr.push(fn(xs[i]));    
                }
                return arr;
              }

              map(["an", "array", "of", "strings"], function(word){
                return word.toUppercase();
              });
              //=> ["AN", "ARRAY", "OF", "STRINGS"]
      </script></section>

      <section data-markdown><script type="text/template">
          # filter

          Takes an array of items and applies a predicate (a function that returns either true or false) to each of them. Returns a list of those items that satisfy the predicate.

              function filter(xs, pred){
                var filtered = [];
                for (var i = 0; i < xs.length; i++) {
                  var item = xs[i];
                  if (pred(item)) filtered.push(item);
                }
                return filtered;
              }

              filter(["one", 2, 3, "four", "five", 6], function(item){
                return _.isNumber(item);
              });
              //=> [2, 3, 6] 
          
      </script></section>

      <section data-markdown><script type="text/template">
          # reduce

          Applies a function against an accumulated value and each value of an array, from left-to-right, and reduces down to a single value.

              function reduce(xs, fn, initial){
                var result = initial;
                for (var i = 0; i < xs.length; i++) {
                  result = fn(result, xs[i]);
                }
                return result;
              }

              function add(a, b){ return a + b; }

              reduce([1,2,3,4,5], add, 0);
              //=> 15

      </script></section>

      <section data-markdown><script type="text/template">

      // Or, a slightly less-contrived example

      function flatten(a, b){ return a.concat(b); }

      reduce([[0, 1], [2, 3], [4, 5]], flatten, []);
      //=> [0, 1, 2, 3, 4, 5]
              
      </script></section>

      <section>
        <h3>Making Our Own</h3>

        <pre><code class="javascript">
        function getText(el){ return el.innerText }

        var links = document.getElementsByClassName('link');

        map(links, getText);
        //=> ["Home", "About", "Blog", "Contact"]
        </code></pre>
                
        <p>Instead of passing a function into `map`, could write a HOF that instead takes a function and turns into a mapping:</p>

      <pre><code class="javascript">
      function splat(fn){
        return function(xs){
          return Array.prototype.map.call(list, fn);
        }
      }

      // Create a new mapping function from `pluck`:
      var mapGetText = splat(getText);

      mapGetText(links);
      //=> ["Home", "About", "Blog", "Contact"]
      </code></pre>
      </section>

      <section>
        <p>If we didn't use `splat`, we'd have to write something like this out every time we wanted to construct a function that maps an array to a result:</p>

        <pre><code class="javascript">
          function mapGetText(xs){
            return xs.map(function(x){
              return x.innerText;
            });
          }
        </pre></code>
      </section>

      <section>
        <h3>What about objects?</h3>
        <br/>
        <p><code>get</code> - takes the name of a property and returns a function 
    that gets that property from an object:</p>
        <pre><code class="javascript">
            function get(prop){
              return function(object){
                return object[prop];
              };
            }

            var user = {
              'name': 'John',
              'age': 32,
              'location': 'London'
            };

            get('location')(user);
            //=> 'London'
        </code></pre>
      </section>

      <section>
        <pre><code class="javascript">
        var users = [
          { 'name': 'John', 'age': 32, 'location': 'London' },
          { 'name': 'Wendy', 'age': 19, 'location': 'Amsterdam' },
          { 'name': 'Sheila', 'age': 41, 'location': 'New York' }
        ];
        </code></pre>
        <p>Now we can make our earlier <code>splat</code> function work for us:</p>
        <pre><code class="javascript">
        var firstNames = splat(get('name'))(users);
        //=> ["John", "Wendy", "Sheila"]

        // Which is nicer that writing:
        var firstNames = splat(function(user){
          return user.name
        })(users);
        </code></pre>
      </section>
      
      <section>
        <p>Such a common pattern that we can take things up another level:</p>
        <pre><code class="javascript">
        function pluck(prop){
          return splat(get(prop));
        }

        pluck('name')(users);
        //=> ["John", "Wendy", "Sheila"]
        </code></pre>
        <br/>
        <p>Libraries like Lo-Dash implement this in a slightly different format:</p>
        <pre><code class="javascript">
        _.pluck(users, 'name');
        //=> ["John", "Wendy", "Sheila"]
        </code></pre>
      </section>

      <section data-markdown>
        # Your turn!
      </section>
      
      <section data-markdown ><script type="text/template">
          # Any other questions?

          ## @timruffles, @mattfieldy
      </script></section>

      </div>
    </div>

    <!-- reveal -->
    <script src="reveal/lib/js/head.min.js"></script>
    <script src="reveal/js/reveal.min.js"></script>
    <script>
      Reveal.initialize({

      // Display controls in the bottom right corner
      controls: false,

      // Display a presentation progress bar
      progress: true,

      // Push each slide change to the browser history
      history: true,

      // Enable keyboard shortcuts for navigation
      keyboard: true,

      // Enable the slide overview mode
      overview: true,

      // Vertical centering of slides
      center: false,

      // Loop the presentation
      loop: false,

      // Change the presentation direction to be RTL
      rtl: false,

      // Number of milliseconds between automatically proceeding to the
      // next slide, disabled when set to 0, this value can be overwritten
      // by using a data-autoslide attribute on your slides
      autoSlide: 0,

      // Enable slide navigation via mouse wheel
      mouseWheel: false,

      // Apply a 3D roll to links on hover
      rollingLinks: false,

      // Transition style
      transition: 'linear', // default/cube/page/concave/zoom/linear/fade/none

      dependencies: [
      // Cross-browser shim that fully implements classList - https://github.com/eligrey/classList.js/
      { src: 'reveal/lib/js/classList.js', condition: function() { return !document.body.classList; } },

      // Interreveal/pret Markdown in <section> elements
        { src: 'reveal/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        { src: 'reveal/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },

        // Syntareveal/x highlight for <code> elements
          { src: 'reveal/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },

          // Zoom reveal/in and out with Alt+click
          { src: 'reveal/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },

          // Speakreveal/er notes
          { src: 'reveal/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },

          // Remotreveal/e control your reveal.js presentation using a touch device
          // { src: 'reveal/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
          ]

          });
    </script>
</body>

