<!DOCTYPE html>
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Functional Programming In Javascript</title>
  
  <link rel="stylesheet" href="reveal/css/reveal.min.css">
  <link rel="stylesheet" href="reveal/lib/css/googlecode.css">

  <link rel="stylesheet" href="slides-theme/style.css">
  <link rel="stylesheet" href="slides-theme/talk-specific.css">
</head>

<body>

  <div class="reveal">
    <div class="slides">

      <section data-markdown><script type="text/template">
          # Functional Javascript

          Code: [github.com/funjsldn/fun-js-class](https://github.com/funjsldn/fun-js-class)

          [@timruffles](http://twitter.com/timruffles)
            
      </script></section>

      <section data-markdown ><script type="text/template">
          # What is FP?
      </script></section>

<section data-markdown><script type="text/template">
## Programming with functions
</script></section>

<section data-markdown><script type="text/template">
## You can leave now
</script></section>

<section data-markdown><script type="text/template">
## But how do I...

- polymorphism
- abstraction
- API design
- ... not obvious how to do with just functions
</script></section>

<section data-markdown><script type="text/template">
## Also: FP has great ideas...
</script></section>

<section data-markdown><script type="text/template">
## ...shame it's hidden by...
</script></section>

<section data-markdown><script type="text/template">
## ...the jargon

![category of endofunctors](img/jargon.png)
</script></section>

<section data-markdown><script type="text/template">
## Let's KISS
</script></section>

<section data-markdown><script type="text/template">
## What are the defining features of FP?
</script></section>

<section data-markdown><script type="text/template">
## Functional programmers have issues

</script></section>
<section data-markdown class='full-image' data-state=snobs><script type="text/template">
## They're snobs
</script></section>
<section data-markdown data-state=change><script type="text/template">
## They're scared of change
</script></section>
<section data-markdown data-state=split><script type="text/template">
## They have split personalities
</script></section>

<section data-markdown><script type="text/template">
## 1. First class functions
</script></section>

<section data-markdown><script type="text/template">
## First-class-functions

- First class: use wherever you can use other values

```javascript
function doTwice(fn) {
  fn() // fn has been passed in as an argument
  fn()
}

doTwice(function() {
  console.log("Hello!")
})

function doubleFn(fn) {
  return function() { // with FCFs we can return functions
    doTwice(fn)
  }
}

var doubleTalk = doubleFn(function() {
  console.log("I'm going to be saying this twice")
})

doubleTalk()
```
</script></section>

<section data-markdown><script type="text/template">
## Higher order functions

- we can pass functions to functions to functions...

```javascript
function loop(fn) {
  fn()
  loop(fn)
}

loop(function() {
  console.log("We'll be here for some time")
})
```

</script></section>

<section data-markdown><script type="text/template">
## First-class fns are good indicator for FP code

- can't do much in FP without FCFs

</script></section>

<section data-markdown><script type="text/template">
## 2. Fear of change(able variables)
</script></section>

<section data-markdown><script type="text/template">
- below code is in a loop in AngularJS
- yes this is an extreme example

```javascript
    // Insanity Warning: scope depth-first traversal
    // yes, this code is a bit crazy, but it works and we have tests to prove it!
    // this piece should be kept in sync with the traversal in $broadcast
    if (!(next = (current.$$childHead || (current !== target && current.$$nextSibling)))) {
      while(current !== target && !(next = current.$$nextSibling)) {
        current = current.$parent;
      }
    }
  } while ((current = next));

  if(dirty && !(ttl--)) {
    clearPhase();
    throw $rootScopeMinErr('infdig',
        '{0} $digest() iterations reached. Aborting!\nWatchers fired in the last 5 iterations: {1}',
        TTL, toJson(watchLog));
  }
} while (dirty || asyncQueue.length);
```
</script></section>

<section data-markdown><script type="text/template">
## See change, hide it

- change is tricky, abstract it

```javascript
var numbers = [1,50,25,12,33,50]
var squares = []
for(var i = 0, len = numbers.length; i < len; i++)
  squares[i] = numbers[i] * numbers[i]
```

```javascript
var quickSquares = numbers.map(square)
function square(x) { return x * x }
```
</script></section>

<section data-markdown><script type="text/template">
## Bigger picture

- lack of shared changable values = safe parallism
- e.g map reduce: map breaks work into parallisable work
- simplicity more relevent than parallelism to JS

</script></section>


<section data-markdown ><script type="text/template">

## 3. Split 'launch rocket' from 'computer answer' 

</script></section>

<section data-markdown ><script type="text/template">

## Computing is safer

![side effects are avoided in functional programming](img/side-effects.png)

</script></section>

<section data-markdown ><script type="text/template">

```javascript
// lots of messy, hard to test asynchronous IO
$(".showFollowerStats",function() {
  Followers.fetch(user,{
    success: function() {
      // hiding some really easy computation
      var ids = []; 
      for(var i = 0, len = followers.length; i < len; i++)
        ids.push(followers.id)
      display(ids)
    }
  })
})
```

</script></section>

<section data-markdown ><script type="text/template">

```javascript
$(".showFollowerStats",function() {
  Followers.fetch(user,{
    success: withFollowers
  })
})
// easy to test/reason about
function withFollowers(followers) {
  // relies only on input
}
function display() {}
```

</script></section>

<section data-markdown><script type="text/template">
## Personality disorders

1. snobbish about their functions
1. scared of change
1. split personalities

</script></section>


<section data-markdown><script type="text/template">
## Sniff tests for FP

1. first class functions
1. scared of change(able variables)
1. divide 'launch rocket' from 'compute answer'

</script></section>

<section data-markdown><script type="text/template">
## Three is a magic number

- always be suspcious of lists of three things
</script></section>


<section data-markdown><script type="text/template">
## How is FP different?
</script></section>

<section data-markdown><script type="text/template">
## vs plain structured programming

- FCF = less repetition
- FCF = more structure
- less reliance on mutable variables
- division of 'launch rocket' from 'compute'
- not really seen much in JS, as FCFs everywhere

</script></section>

<section data-markdown><script type="text/template">
## vs OOP

> OOP to me means only messaging, local retention and protection and hiding of state-process, and extreme late-binding of all things.

Alan Kay


</script></section>

<section data-markdown><script type="text/template">
## Technical diagram
- messaging/late binding
- hiding of state
![technical diagram of OOP](img/messaging.png)
</script></section>

<section data-markdown><script type="text/template">
## Messaging & late-binding

- component sends a message
- another components receives and does... whatever it likes
- decouples intent from implementation

</script></section>

<section data-markdown><script type="text/template">
## Late binding achieves polymorphism
</script></section>


<section data-markdown><script type="text/template">
## Hiding of state

- ideally: can only send messages
- therefore no idea if state held locally, or via pidgeon messanger

```javascript
function User() {}
User.prototype.getName = function() {
  return blockingPidegonFetch("name")
}

var user = new User
user.name // can't be intercepted/Kay late-bound
user.getName() // can be intercepted/Kay late-bound
```

</script></section>


<section data-markdown><script type="text/template">

## Does FP throw this out?

- polymorphism: nope
- late-binding: nope
- hiding state: mostly yes
- messaging: mostly yes

</script></section>

<section data-markdown><script type="text/template">
## OOP in practice

> I'm sorry that I long ago coined the term "objects" for this topic because it gets many people to focus on the lesser idea. The big idea is "messaging"

- classes, inheritance etc just implementation

</script></section>


<section data-markdown><script type="text/template">

## Hiding data hides it

- data is easy to manipulate via pure functions
- objects hide data away inside one-off APIs

</script></section>

<section data-markdown><script type="text/template">

## Means vs Ends

- messaging/hiding state are means, not design goals

</script></section>

<section data-markdown><script type="text/template">

## Ends

- polymorphism: many compatible implementations
- late-binding: can change implemenation at run-time

</script></section>

<section data-markdown data-state=title><script type="text/template">
## Nuts'n'bolts
</script></section>

<section data-markdown><script type="text/template">

## Defining functions

```javascript
var hello = function hello(x) {
  return "hello " + x;
};

function greetings(x) {
  return "greetings " + x;
}
```

</script></section>

<section data-markdown><script type="text/template">

## What's the difference?

```javascript

greetings("haskell");
hello("erlang");

var hello = function hello(x) {
  return "hello " + x;
};

function greetings(x) {
  return "greetings " + x;
}
```

</script></section>

<section data-markdown><script type="text/template">

## Closure

```javascript

var youCanSeeMe = "hello";

function greetings() {
  return "greetings " + youCanSeeMe;
}
function howdy(youCanSeeMe) {
  return "howdy " + youCanSeeMe;
}
```

</script></section>


<section data-markdown><script type="text/template">

## Closures: define-time

- spot the bug

```javascript
var els = document.querySelectAll("button");
for(var i = 0, len = els.length; i < len; i++) {
  els[i].addEventListener("click",function() {
    console.log("You clicked on the button marked " +
     els[i].innerText);
  });
}
```

</script></section>

<section data-markdown><script type="text/template">

## Let's have arguments

- local variable defined for each function *invocation*

```javascript
function callMe() {
  // who needs parameters?
  console.log("Hello " + arguments[0]);
}
callMe("a");
```

</script></section>

<section data-markdown><script type="text/template">

## Call me

- JS's split function/object personality 
- `Function.pt.call = ƒ(thisArg,arg1,arg2 [,argN])`

```javascript
function toppyTail() {
  var head = arguments[0];
  var tail = [].slice.call(arguments,1);
  return [head,tail]
}

toppyTail("a","b","c") // ["a",["b","c"]]
```

</script></section>

<section data-markdown><script type="text/template">

## Apply me

- `Function.pt.apply = ƒ(thisArg,[arg1,arg2 [,argN]])`

```javascript
function flattenOne(array) {
  return [].concat.apply([],array);
}

flattenOne([[1,2,3],4,[5,6],[7,8],9])
```

</script></section>

<section data-markdown><script type="text/template">

## Bind

- JS's split function/object personality again
- `Function.pt.bind = ƒ(thisArg,arg1,arg2[,argN]])→ƒ`

```javascript
var log = console.log.bind(console);
var logContext = console.log.bind(console,"Presentation:");
```

</script></section>

<section data-markdown><script type="text/template">

## The core

- Define: expression or declaration
- Closures to capture
- Arguments
- Call, apply
- Bind

</script></section>

<section data-markdown data-state=title><script type="text/template">
## Let's use them!
</script></section>

<section data-markdown><script type="text/template">
## Exercises

- open folder (Terminal, type `cd ` + drag from finder)
- `npm install`
- `npm test`
- fill in the blanks!
</script></section>

      <section data-markdown data-state=title><script type="text/template">
      ## Time for the real deal
      </script></section>

      <section data-markdown><script type="text/template">
          ## Higher-Order Functions

          * What are they?
          * How do they work?
          * Why would we use them?
          * Exercises
          
      </script></section>

      <section data-markdown ><script type="text/template">
          ## What are HOFs?

          * Functions that do at least one of the following:
          
            1. Take one or more functions as input
            1. Return a function as their result
          
      </script></section>

      <section>

        <pre><code class=javascript>
        function forEach(xs, fn) {
          for (var i = 0; i < xs.length; i++) {
            return fn(xs[i]);
          }
        }
        </code></pre>
        
        <pre><code class="javascript">
        function greaterThan(n) {
          return function(m) {
            return m > n;
          }
        }

        var greaterThan10 = greaterThan(10);
              
        greaterThan10(11);
        //=> true
        </code></pre>
        
      </section>

      <section data-markdown ><script type="text/template">
          #### JavaScript has first-class functions

          <pre><code class=javascript >
              function hello(){
                return "Hello, world!";
              }

              hello();
              //=> "Hello, world!"

              hello;
              //=> "function hello()"

              var ohai = hello;

              ohai();
              //=> "Hello, world!"

              function callThis(f){
                return f();
              }

              callThis(hello);
              //=> "Hello, world!"
              
          </code></pre>
      </script></section>

      <section data-markdown><script type="text/template">
          ## Why would you use them?

      </script></section>

      <section data-markdown><script type="text/template">
          > There are two ways of constructing software:
          > make it so simple that there are obviously no
          > deficiencies, or make it so complicated
          > that there are no obvious deficiencies. 
          >
          > -- C.A.R Hoare, 1980 ACM Turing Award Lecture
      </script></section>

      <section data-markdown ><script type="text/template">
          <p class="center">Which is more likely to contain a bug?</p>
          
          <pre><code class=javascript>
              // Self-contained, six-lines long
              var total = 0, count = 1;
              while (count <= 10) {
                total = count;
                count += 1;
              }
              console.log(total);                
          </code></pre>
          <pre><code class=javascript>
              // Relies on two external functions, one line long
              console.log(sum(range(1, 10)));
              
          </code></pre>

          <aside class="notes">
            * Program needed to write the second longer than the first, but more likely to be correct
            * By building a language in which to express problem, then solving in terms of the problem's domain, solution gains clarity
            * i.e. summing a range of numbers isn't about loops and counters, but ranges and sums
          </aside>
      </script></section>

      <section>
        <p>Powerful level of abstraction over <em>actions</em> not just values</p>

        <pre><code class=javascript >
          function unless(test, then){
            if (!test) then();
          }

          function repeat(times, body){
            for (var i = 0; i < times; i++) body(i);
          }

          repeat(3, function(n){
            unless(n % 2, function(){
              console.log(n, "is even");
            });
          });
        </code></pre>
      </section>

      <section data-markdown ><script type="text/template">
          ## Familiar Examples

          Canonical examples:
          
          * map
          * filter
          * reduce
      </script></section>
      
      <section data-markdown><script type="text/template">
          ## map

              function map(xs, fn){
                var arr = [];
                for (var i = 0; i < xs.length; i++) {
                  arr.push(fn(xs[i]));    
                }
                return arr;
              }

              map(["an", "array", "of", "strings"], function(word){
                return word.toUppercase();
              });
              //=> ["AN", "ARRAY", "OF", "STRINGS"]


            <aside class="notes">
              Takes an array of items and applies a function to each item in that array, then returns a *new* array whose items are the result.
            </aside>
      </script></section>

      <section data-markdown><script type="text/template">
          ## filter

              function filter(xs, pred){
                var filtered = [];
                for (var i = 0; i < xs.length; i++) {
                  var item = xs[i];
                  if (pred(item)) filtered.push(item);
                }
                return filtered;
              }

              filter(["one", 2, 3, "four", "five", 6], function(item){
                return _.isNumber(item);
              });
              //=> [2, 3, 6]

            <aside class="notes">
              Takes an array of items and applies a predicate (a function that returns either true or false) to each of them. Returns a list of those items that satisfy the predicate.
            </aside>
          
      </script></section>

      <section data-markdown><script type="text/template">
          ## reduce

              function reduce(xs, fn, initial){
                var result = initial;
                for (var i = 0; i < xs.length; i++) {
                  result = fn(result, xs[i]);
                }
                return result;
              }

              function add(a, b){ return a + b; }

              reduce([1,2,3,4,5], add, 0);
              //=> 15

              // Or, a slightly less-contrived example

              function flatten(a, b){ return a.concat(b); }

              reduce([[0, 1], [2, 3], [4, 5]], flatten, []);
              //=> [0, 1, 2, 3, 4, 5]
            <aside class="notes">
              Applies a function against an accumulated value and each value of an array, from left-to-right, and reduces down to a single value.
            </aside>
      </script></section>

      <section data-state=title>
        <h2>Making Our Own</h2>
      </section>

      <section>
        <pre><code class=javascript>
        function getText(el){ return el.innerText }

        var links = document.getElementsByClassName('link');

        map(links, getText);
        //=> ["Home", "About", "Blog", "Contact"]
        </code></pre>
                
        <aside class="notes">
          Instead of passing a function into `map`, could write a HOF that instead takes a function and turns into a mapping:
        </aside>

      <p>Turn a function into a mapping</p>
      <pre><code class=javascript>
        function splat(fn){
          return function(xs){
            return Array.prototype.map.call(list, fn);
          }
        }

        // Create a new mapping function from `pluck`:
        var mapGetText = splat(getText);

        mapGetText(links);
        //=> ["Home", "About", "Blog", "Contact"]
      </code></pre>
      </section>

      <section>
        <p>If we didn't use <code>splat</code></p>

        <pre><code class=javascript >
          function mapGetText(xs){
            return xs.map(function(x){
              return x.innerText;
            });
          }
        </pre></code>
        
      </section>

      <section>
        <h3>What about objects?</h3>
        <p><code>get</code> - takes the name of a property and returns a function 
    that gets that property from an object:</p>
        <pre><code class=javascript >
            function get(prop){
              return function(object){
                return object[prop];
              };
            }

            var user = {
              'name': 'John',
              'age': 32,
              'location': 'London'
            };

            get('location')(user);
            //=> 'London'
        </code></pre>
      </section>

      <section>
        <pre><code class=javascript >
        var users = [
          { 'name': 'John',
             'age': 32,
             'location': 'London' },
          { 'name': 'Wendy',
            'age': 19,
            'location': 'Amsterdam' },
          { 'name': 'Sheila',
            'age': 41,
            'location': 'New York' }
        ];
        </code></pre>
        <p>Now we can make our earlier <code>splat</code> function work for us:</p>
        <pre><code class=javascript >
        var firstNames = splat(get('name'))(users);
        //=> ["John", "Wendy", "Sheila"]

        // Which is nicer that writing:
        var firstNames = splat(function(user){
          return user.name
        })(users);
        </code></pre>
      </section>
      
      <section>
        <p>Such a common pattern that we can take things up another level:</p>
        <pre><code class=javascript >
        function pluck(prop){
          return splat(get(prop));
        }

        pluck('name')(users);
        //=> ["John", "Wendy", "Sheila"]
        </code></pre>
        <br/>
        <p>Libraries like Lo-Dash implement this in a slightly different format:</p>
        <pre><code class=javascript >
        _.pluck(users, 'name');
        //=> ["John", "Wendy", "Sheila"]
        </code></pre>
      </section>

      <section data-markdown data-state=title>
        ## Your turn

        ## Implementing Underscore
      </section>
<section data-markdown data-state=title><script type="text/template">

## Time in FP


</script></section>

<section data-markdown><script type="text/template">

## Time is tricky

```javascript
function updateProfile(req,res) {
  getUser(res.params.userId,function(err,user) {
    if(err) return res.send(404);
    getProfile(user,function(err,profile) {
      if(err) return res.send(500);
      updateProfile(user,profile,req.params.profile,function(err) {
        if(err) return res.send(500);
      });
    })
  })
}
```

</script></section>


<section data-markdown><script type="text/template">

## Where are the values?

</script></section>

<section data-markdown><script type="text/template">

## We're really saying

```javascript
var user = getUser(params["id"]);
if(!user) return res.send(404);

try {
  var profile = getProfile(user);
  if(profile) {
    update(user,profile,params);
  } else {
    profile = create(user,params);
  }
  return res.send(profile);
} catch(e) {
  res.send(500);
}
```

</script></section>

<section data-markdown><script type="text/template">

## Like a spread-sheet

- values with inter-relations

```javascript
var user = getUser(params["id"]);
var profile = getProfile(user);
var accountPage = accountPageTemplate(user,profile);
```

</script></section>


<section data-markdown><script type="text/template">

## How do we get back to values?

</script></section>

<section data-markdown><script type="text/template">

## Promises

</script></section>

<section data-markdown><script type="text/template">

## An IOU

- A promise is a value, returned immediately
- Later fulfilled or rejected - once
- Can use before or after value arrives
- Chain promises together

</script></section>

<section data-markdown><script type="text/template">

## Intuition

![Promise chain](img/promises.png)

</script></section>


<section data-markdown><script type="text/template">

## Promises in practice

- `.then()` with a function that accepts the value when it arrives
- `.then()` returns a new promise - for the return value of the function

```javascript
var user = getUser(params["id"]);
var profile = user.then(getProfile);
var accountPage = Promise.spread(user,profile).then(accountPageTemplate);

accountPage.then(
  renderToDom,
  renderErrorMessage
);
```

</script></section>

<section data-markdown><script type="text/template">

## In detail

```javascript
var aTennerLater = new Promise(function(resolve) {
  setTimeout(function() { resolve(10) },500)
});

var sweets = aTennerLater.then(function(money) {
  if(money < 10) throw new Error("Too little money to fulfil!");
  return { type: "liquorice", value: money };
});

var alicesMood = sweets.then(function(sweets) {
  return {
    mood: "Happy! She got " + sweets.value
      + " pounds worth of " + sweets.type
  }
},function(failureReason) {
  return {
    mood: "Grumpy! No sweets because " + failureReason
  }
});
```

</script></section>


<section data-markdown><script type="text/template">

## Can handle multiple dependencies

- Doesn't require nesting - we have values!
- we'll be writing spread

```javascript
var user = getUser(params["id"]);
var profile = user.then(getProfile);
var accountPage = Promise.all([user,profile])
  .then(function(results) {
    return accountPageTemplate.apply(null,results);
  });
```

</script></section>

<section data-markdown><script type="text/template">

## Enumerations

- No library code for maps to promises
- Still requires library for more interesting enumeration

```javascript
[fileA,fileB,fileC].map(function(f) {
  return readFile(f)
}).map(function(contents) {
  return contents.then(transform);
}) // list of promises for transformed content
```

</script></section>

<section data-markdown data-state=title><script type="text/template">
## Let's use some!
</script></section>

<section data-markdown><script type="text/template">
## So...
</script></section>

<section data-markdown><script type="text/template">
## You're developing personality flaws

1. snobbish about your functions
1. wary of changeable variables
1. split your IO from your computation
</script></section>

<section data-markdown><script type="text/template">
## Next steps

1. become a little Lisper: Clojurescript
1. bang your head on Haskell via Elm
1. get serious about reliability: Erlang

</script></section>

<section data-markdown ><script type="text/template">
    # Any other questions?

    ### [@timruffles](http://twitter.com/timruffles)
</script></section>

<section data-markdown><script type="text/template">
## p.s you've used a monad
</script></section>




<section data-markdown ><script type="text/template">

## Creative commons work

- [split personality, eelsmann](http://www.flickr.com/photos/eelsmann/2516127452/)
- [scared of change, Doug Brown](http://www.flickr.com/photos/49814332@N04/8003059230/)
- [snob, Bethany](http://www.flickr.com/photos/bethanyegan/6565582497/)
- [power combined](http://www.flickr.com/photos/kinguday/4540065698/)

</script></section>


</div>
</div>

<!-- reveal -->
<script src="reveal/lib/js/head.min.js"></script>
<script src="reveal/js/reveal.min.js"></script>
<script>
  Reveal.initialize({

    // Display controls in the bottom right corner
    controls: false,

    // Display a presentation progress bar
    progress: true,

    // Push each slide change to the browser history
    history: true,

    // Enable keyboard shortcuts for navigation
    keyboard: true,

    // Enable the slide overview mode
    overview: true,

    // Vertical centering of slides
    center: false,

    // Loop the presentation
    loop: false,

    // Change the presentation direction to be RTL
    rtl: false,

    // Number of milliseconds between automatically proceeding to the
    // next slide, disabled when set to 0, this value can be overwritten
    // by using a data-autoslide attribute on your slides
    autoSlide: 0,

    // Enable slide navigation via mouse wheel
    mouseWheel: false,

    // Apply a 3D roll to links on hover
    rollingLinks: false,

    // Transition style
    transition: 'linear', // default/cube/page/concave/zoom/linear/fade/none

    dependencies: [
        // Cross-browser shim that fully implements classList - https://github.com/eligrey/classList.js/
        { src: 'reveal/lib/js/classList.js', condition: function() { return !document.body.classList; } },

        // Interreveal/pret Markdown in <section> elements
    { src: 'reveal/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
            { src: 'reveal/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },

        // Syntareveal/x highlight for <code> elements
          { src: 'reveal/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },

          // Zoom reveal/in and out with Alt+click
          { src: 'reveal/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },

          // Speakreveal/er notes
          { src: 'reveal/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },

          // Remotreveal/e control your reveal.js presentation using a touch device
          // { src: 'reveal/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
          ]

          });
    </script>
</body>

